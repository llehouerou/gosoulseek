# Soulseek Download Protocol - Architecture Analysis

This document provides an in-depth analysis of the Soulseek file download protocol based on:
- The Soulseek Protocol Documentation (HTML)
- The Soulseek.NET reference implementation
- Protocol analysis and testing

## Table of Contents

1. [Overview](#overview)
2. [Message Types](#message-types)
3. [Connection Types](#connection-types)
4. [Token Management](#token-management)
5. [Download Flow - Detailed](#download-flow---detailed)
6. [Inbound Connection Handling](#inbound-connection-handling)
7. [Wire Protocol Details](#wire-protocol-details)
8. [Common Issues](#common-issues)

---

## Overview

Soulseek uses a hybrid client-server architecture where:
- The **server** handles user discovery, search distribution, and connection brokering
- **Peers** communicate directly for file transfers and search results

A file download involves multiple connection types and message exchanges between the downloader (client requesting file) and the uploader (peer sharing files).

---

## Message Types

### Initialization Messages (1-byte code)

These are the first messages sent on a new peer connection. They use a **single byte** code (not 4 bytes like regular peer messages).

| Code | Name | Description |
|------|------|-------------|
| `0x00` | PierceFirewall | Sent when connecting via server's ConnectToPeer instruction (NAT traversal) |
| `0x01` | PeerInit | Sent when initiating a direct connection |

### PeerInit Message Structure

```
[4-byte length][1-byte code=1][4-byte username_len][username bytes][4-byte type_len][type bytes][4-byte token]
```

Example for username "alice", type "F", token 12345:
```
Length: 1 + (4+5) + (4+1) + 4 = 19 bytes
Bytes:  [19 00 00 00][01][05 00 00 00][a l i c e][01 00 00 00][F][39 30 00 00]
```

### PierceFirewall Message Structure

```
[4-byte length][1-byte code=0][4-byte token]
```

### Peer Messages (4-byte code)

Regular peer messages use a 4-byte little-endian code.

| Code | Name | Direction | Description |
|------|------|-----------|-------------|
| 40 | TransferRequest | Both | Request/offer file transfer |
| 41 | TransferResponse | Both | Accept/reject transfer |
| 43 | QueueDownload | C→P | Add file to peer's queue |
| 44 | PlaceInQueueResponse | P→C | Report queue position |
| 46 | UploadFailed | P→C | Transfer failed mid-stream |
| 50 | UploadDenied | P→C | Transfer denied with reason |
| 51 | PlaceInQueueRequest | C→P | Request queue position |

---

## Connection Types

### P-Type (Peer Message Connection)

- **Identifier**: `"P"` in PeerInit
- **Purpose**: Control messages, search results, transfer negotiation
- **Protocol**: Framed messages with `[4-byte length][4-byte code][payload]`
- **Lifetime**: Can be persistent, reused for multiple operations

### F-Type (File Transfer Connection)

- **Identifier**: `"F"` in PeerInit
- **Purpose**: Raw binary file data transfer
- **Protocol**: Unframed after initialization
- **Lifetime**: Single transfer, closed when complete

### Connection Flow Summary

```
                    ┌─────────────────────────────────────┐
                    │           P-Type Connection          │
                    │  (Control messages, negotiation)     │
Downloader ◄───────►│  TransferRequest/Response           │◄───────► Uploader
                    │  PlaceInQueue, UploadDenied, etc    │
                    └─────────────────────────────────────┘

                    ┌─────────────────────────────────────┐
                    │           F-Type Connection          │
                    │  (Raw file data transfer)            │
Downloader ◄────────│  PeerInit/"F" → Offset → FileData   │─────────► Uploader
                    └─────────────────────────────────────┘
```

---

## Token Management

### Local Token (Downloader's Token)

- Generated by the downloader when initiating a download
- Used in the initial `TransferRequest(Download)` message
- Purpose: Allows downloader to correlate responses

### Remote Token (Uploader's Token)

- Generated by the uploader when ready to transfer
- Sent in `TransferRequest(Upload)` message (the "start notification")
- **Critical**: This is the token used in the F-type connection
- Purpose: Allows uploader to identify which transfer this connection is for

### Token Flow

```
Downloader                          Uploader
    │                                   │
    │  TransferRequest(dir=DL, token=T1, filename)
    │──────────────────────────────────►│
    │                                   │
    │  TransferResponse(T1, "Queued")   │
    │◄──────────────────────────────────│
    │                                   │
    │  ... (file reaches front of queue) ...
    │                                   │
    │  TransferRequest(dir=UL, token=T2, filename, size)
    │◄──────────────────────────────────│
    │                                   │
    │  (store T2 as remoteToken)        │
    │                                   │
    │  TransferResponse(T2, size)       │
    │──────────────────────────────────►│
    │                                   │
    │  ═══════ F-Type Connection ═══════│
    │◄──────────────────────────────────│
    │  PeerInit("uploader", "F", T2)    │
    │  [4 bytes: T2]                    │
    │                                   │
    │  [8 bytes: StartOffset]           │
    │──────────────────────────────────►│
    │                                   │
    │  [Raw file data...]               │
    │◄──────────────────────────────────│
```

---

## Download Flow - Detailed

### Phase 1: Initial Request (P-Type Connection)

The downloader sends a TransferRequest on a P-type connection:

```
TransferRequest {
    Code:      40 (4 bytes)
    Direction: 0 (Download) (4 bytes)
    Token:     <local_token> (4 bytes)
    Filename:  <remote_path> (length-prefixed string)
}
```

### Phase 2: Response Handling

The uploader responds with TransferResponse:

```
TransferResponse {
    Code:     41 (4 bytes)
    Token:    <local_token> (4 bytes)
    Allowed:  <0 or 1> (1 byte)

    If Allowed=1:
        FileSize: <size> (8 bytes)
    If Allowed=0:
        Reason: <string> (length-prefixed)
}
```

**If Allowed=1**: Proceed directly to Phase 4 (transfer connection)

**If Reason="Queued"**: Wait for Phase 3

### Phase 3: Queue Notification (When Queued)

When the file reaches the front of the queue, the uploader sends:

```
TransferRequest {
    Code:      40 (4 bytes)
    Direction: 1 (Upload) (4 bytes)
    Token:     <remote_token> (4 bytes)  ← UPLOADER'S TOKEN
    Filename:  <remote_path> (length-prefixed string)
    FileSize:  <size> (8 bytes)
}
```

The downloader must:
1. Store `remote_token` for later use
2. Send back acknowledgment:

```
TransferResponse {
    Code:     41 (4 bytes)
    Token:    <remote_token> (4 bytes)  ← USE UPLOADER'S TOKEN
    Allowed:  1 (1 byte)
    FileSize: <size> (8 bytes)
}
```

### Phase 4: Transfer Connection Establishment

After the TransferResponse acknowledgment, the uploader establishes an F-type connection.

**The connection can be established in two ways:**

#### Direct Connection (Uploader → Downloader)

1. Uploader connects directly to downloader's listener port
2. Uploader sends: `PeerInit(username, "F", remote_token)`
3. Uploader sends: `<remote_token>` as raw 4 bytes
4. Connection ready for data transfer

#### Indirect Connection (Via Server)

If direct connection fails:

1. Uploader asks server to tell downloader to connect back
2. Server sends `ConnectToPeer` to downloader
3. Downloader connects to uploader
4. Downloader sends: `PierceFirewall(solicitation_token)`
5. Uploader sends: `<remote_token>` as raw 4 bytes
6. Connection ready for data transfer

### Phase 5: File Data Transfer

Once the F-type connection is established:

1. **Downloader sends**: 8-byte offset (little-endian Int64)
   - `0` for full file download
   - `N` for resume from byte N

2. **Uploader sends**: Raw file bytes starting from offset
   - No framing, no length prefix
   - Pure binary data
   - Transfer ends when `FileSize - Offset` bytes received

```
Downloader                              Uploader
    │                                       │
    │  [8 bytes: StartOffset = 0]           │
    │──────────────────────────────────────►│
    │                                       │
    │  [file data bytes...]                 │
    │◄──────────────────────────────────────│
    │◄──────────────────────────────────────│
    │◄──────────────────────────────────────│
    │  ...until FileSize bytes received     │
    │                                       │
    │  [connection closed]                  │
```

---

## Inbound Connection Handling

### ListenerHandler Flow (Receiving Incoming Connections)

```
Accept TCP Connection
        │
        ▼
Read 4-byte length
        │
        ▼
Read message body
        │
        ▼
Check first byte (init code)
        │
        ├── 0x00 (PierceFirewall)
        │       │
        │       ▼
        │   Extract solicitation_token
        │       │
        │       ├── Match pending solicitation?
        │       │       YES → Complete wait, hand off connection
        │       │
        │       └── NO → Read 4-byte remote_token
        │               │
        │               ▼
        │           Match pending download?
        │               YES → Hand off to download
        │               NO  → Close connection
        │
        └── 0x01 (PeerInit)
                │
                ▼
            Parse username, type, token
                │
                ├── Type = "P" (Peer Messages)
                │       └── Start message read loop
                │
                ├── Type = "F" (File Transfer)
                │       │
                │       ▼
                │   Read 4-byte remote_token
                │       │
                │       ▼
                │   Match pending download by (username, remote_token)?
                │       YES → Hand off connection to download
                │       NO  → Close connection
                │
                └── Type = "D" (Distributed)
                        └── Not implemented
```

### Critical: No Token Echo

When receiving an F-type connection (PeerInit or PierceFirewall), the receiver:
1. Reads the 4-byte remote_token
2. **Does NOT send any token back**
3. Immediately hands off the connection

The next data expected by the uploader is the 8-byte StartOffset from the downloader.

---

## Wire Protocol Details

### Message Framing (P-Type)

All P-type messages use length-prefixed framing:

```
┌──────────────┬──────────────┬─────────────────────┐
│ Length (4B)  │ Code (4B)    │ Payload (variable)  │
└──────────────┴──────────────┴─────────────────────┘
     LE uint32      LE uint32
```

The length includes the code but not itself.

### Initialization Messages

Initialization messages use 1-byte codes:

```
┌──────────────┬──────────────┬─────────────────────┐
│ Length (4B)  │ Code (1B)    │ Payload (variable)  │
└──────────────┴──────────────┴─────────────────────┘
     LE uint32       byte
```

### String Encoding

Strings are length-prefixed:

```
┌──────────────┬─────────────────────┐
│ Length (4B)  │ String bytes (UTF-8)│
└──────────────┴─────────────────────┘
     LE uint32
```

### F-Type Connection Data

After initialization, F-type connections carry raw data:

```
┌───────────────────┬─────────────────────────────────────┐
│ StartOffset (8B)  │ File Data (Size - Offset bytes)     │
└───────────────────┴─────────────────────────────────────┘
    LE int64              Raw binary
```

---

## Common Issues

### 1. Token Echo Bug

**Symptom**: Download hangs after connection establishment

**Cause**: Sending a token back to the uploader after receiving their token

**Fix**: After reading the remote_token on F-type connection, do NOT send anything back. The next step is sending the 8-byte StartOffset.

### 2. Wrong Token in PeerInit

**Symptom**: Uploader cannot match the incoming connection

**Cause**: Using local_token instead of remote_token in PeerInit

**Fix**: When establishing outbound F-type connection, use the `remote_token` (the one received in the uploader's TransferRequest) in PeerInit, not your local token.

### 3. Missing Token Bytes After PeerInit

**Symptom**: Uploader receives PeerInit but connection fails

**Cause**: Not sending the 4-byte token after PeerInit message

**Fix**: After sending PeerInit, immediately send the token as 4 raw bytes.

### 4. Indirect Connection Token Confusion

**Symptom**: Indirect (server-mediated) connections fail

**Cause**: Confusing solicitation_token with remote_token

**Fix**:
- `solicitation_token`: Used in ConnectToPeer/PierceFirewall for server-mediated connection establishment
- `remote_token`: Used to identify the actual file transfer, sent as 4 bytes after connection establishment

---

## Transfer State Machine

```
                    ┌─────────┐
                    │  None   │
                    └────┬────┘
                         │ Download() called
                         ▼
                    ┌─────────┐
                    │ Queued  │ (locally)
                    │ Locally │
                    └────┬────┘
                         │ TransferRequest sent
                         ▼
                    ┌─────────┐
                    │Requested│
                    └────┬────┘
                         │
            ┌────────────┼────────────┐
            │            │            │
            ▼            ▼            ▼
    ┌─────────┐   ┌─────────┐   ┌─────────┐
    │ Queued  │   │Immediate│   │ Denied  │
    │Remotely │   │  Start  │   │         │
    └────┬────┘   └────┬────┘   └─────────┘
         │             │
         │ TransferRequest(Upload) received
         │             │
         ▼             │
    ┌─────────────┐    │
    │Initializing │◄───┘
    └─────┬───────┘
          │ F-type connection established
          ▼
    ┌─────────────┐
    │ InProgress  │
    └─────┬───────┘
          │ All bytes received
          ▼
    ┌─────────────┐
    │  Completed  │
    │  Succeeded  │
    └─────────────┘
```

---

## Soulseek.NET Code References

| Component | File | Key Methods |
|-----------|------|-------------|
| Download Entry | `SoulseekClient.cs` | `DownloadAsync()` (line ~3200) |
| Transfer Request | `TransferRequest.cs` | Message encoding/decoding |
| Transfer Response | `TransferResponse.cs` | Message encoding/decoding |
| Connection Manager | `PeerConnectionManager.cs` | `GetTransferConnectionAsync()`, `AwaitTransferConnectionAsync()` |
| Listener Handler | `ListenerHandler.cs` | `HandleConnection()` |
| PeerInit | `PeerInit.cs` | Message encoding/decoding |
| PierceFirewall | `PierceFirewall.cs` | Message encoding/decoding |

---

## Summary: Correct Download Implementation Checklist

1. [ ] Send TransferRequest(Direction=Download, Token=local_token, Filename)
2. [ ] Handle TransferResponse - check Allowed flag and Reason
3. [ ] If "Queued", wait for TransferRequest(Direction=Upload) from uploader
4. [ ] Store remote_token from uploader's TransferRequest
5. [ ] Send TransferResponse(Token=remote_token, Allowed=true, FileSize)
6. [ ] Wait for F-type connection OR establish outbound F-type
7. [ ] For outbound F-type direct: PeerInit(username, "F", remote_token) + 4-byte remote_token
8. [ ] For inbound F-type: Read 4-byte remote_token, match to pending download
9. [ ] **Do NOT echo token back**
10. [ ] Send 8-byte StartOffset
11. [ ] Read file data until FileSize bytes received
